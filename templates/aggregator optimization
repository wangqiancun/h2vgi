from __future__ import division
import matplotlib.pyplot as plt
import matplotlib
import pandas
import pdb, traceback, sys
import scipy
from scipy import signal
import numpy as np
import datetime
import cPickle as pickle
from pyomo.opt import SolverFactory
from pyomo.environ import *
from pyomo.opt import SolverStatus, TerminationCondition

# read netload and boundaries from excel files, all dictionaries

net_load =
pmax =
pmin =
vmin =
vmax =




with SolverFactory('gurobi') as opt:
    model = ConcreteModel()

    # Set time index, timeindex is a vector
    model.t = Set(initialize=timeindex, doc='Time', ordered=True)

    # Parameters
    model.d = Param(model.t, initialize = net_load, doc='Net load')
    model.p_max = Param(model.t, initialize=pmax, doc='P max')
    model.p_min = Param(model.t, initialize=pmin, doc='P min')
    model.v_min = Param(model.t, initialize=vmin, doc='E min')
    model.v_max = Param(model.t, initialize=vmax, doc='E max')

    # Variables
    model.p = Var(model.t, domain=NonNegativeReals, doc='charging power')

    # Rules
    def maximum_power_rule(model, t):
        return model.p[t] <= model.p_max[t]
    model.power_max_rule = Constraint(model.t, rule=maximum_power_rule, doc='P max rule')

    def minimum_power_rule(model, t):
        return model.p[t] >= model.p_min[t]
    model.power_min_rule = Constraint(model.t, rule=minimum_power_rule, doc='P min rule')

    def minimum_energy_rule(model, t):
        return sum(model.p[i] for i in range(0, t + 1)) >= model.v_min[t]
    model.minimum_energy_rule = Constraint(model.t, rule=minimum_energy_rule, doc='E min rule')

    def maximum_energy_rule(model, t):
        return sum(model.p[i] for i in range(0, t + 1)) <= model.v_max[t]
    model.maximum_energy_rule = Constraint(model.t, rule=maximum_energy_rule, doc='E max rule')

    def objective_rule(model):
        return sum([(model.d[t] + model.p[t])**2 for t in model.t])
    model.objective = Objective(rule=objective_rule, sense=minimize, doc='Define objective function')

    results = opt.solve(model)

    print value(model.objective)


# An example to save decision variable p
df = pandas.DataFrame(index=['Aggregate Power'], data=model.p.get_values()).transpose()

df.to_csv('p.csv')